<head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.6/dist/tf-tflite.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>


    <style>
        #canvas {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            left: 0;
            pointer-events: none;
        }

        #canvas>svg {
            width: 100%;
            height: 100%;
        }

        #container {
            display: inline-block;
            position: relative;
        }
    </style>
</head>

<body>
    <div id="app">

        <h1>TFLite Label Assist - {{ message }}</h1>

        <div id="container">
            <!-- <img id="img" src="goal_test.png"/> -->
            <video id="video" controls></video>
            <div id="canvas"></div>
        </div>

        <button onclick="draw.clear()">Clear</button>

        <div>
            <p>Confidence - {{confidence}}</p>
            <input id="confidence" type="range" min="0" max="1" step="0.05" v-model.number="confidence">

            <p>Prediction per second - {{predictPerSecond}}</p>
            <input id="frame" type="number" v-model.number="predictPerSecond">

            <p>Video length : {{videoDuration}}s</p>
            <p>Predictions : {{predicionCount}}</p>
            <p>Predicting on frame times: {{predicionTimes}}</p>

        </div>

    </div>

</body>
<script>

    // TODO : allow you to specifiy which frames to predict on 
    // TODO : save frame as PNG
    // TODO : save image to Cloud Storage and inject metadata (labels)
    // TODO : allow you to drag and drop videos, models into UI

    // https://serversideup.net/capturing-an-image-from-an-html5-canvas-or-video-element/
    // https://firebase.google.com/docs/storage/web/upload-files
    // https://firebase.google.com/docs/storage/web/file-metadata


    const { createApp, ref } = Vue

    const app = createApp({
        setup() {

            const message = ref('Hello vue!')
            const predictPerSecond = ref(1)
            const confidence = ref(0.5)
            const videoDuration = ref(0)

            return {
                message,
                confidence,
                predictPerSecond,
                videoDuration
            }

        },
        computed: {
            predicionCount() {
                return parseInt(this.videoDuration * this.predictPerSecond)
            },
            // timeBetweenPredictions() {
            //     return 1/this.predictPerSecond
            // },
            predicionTimes() {
                const times = []
                const timeBetweenPredictions = 1 / this.predictPerSecond
                var currentTime = 0
                for (let index = 0; index < this.predicionCount; index++) {
                    times.push(currentTime)
                    currentTime += timeBetweenPredictions
                }
                return times
            }
        },
        mounted() {
            console.log('Mounted app')
        }
    }).mount('#app')


    function getConfidenceValue() {
        return app.confidence
    }

    const video = document.getElementById('video')


    video.onloadeddata = function () {
        console.log("Video loaded , duration", video.duration);
        app.videoDuration = video.duration
    };

    function load_video(src) {
        video.src = src
    }

    load_video("test_video.mp4")


    // video.addEventListener("timeupdate", (event) => {
    //   console.log(video.currentTime);
    //   run()
    // });

    let prev_time = null

    window.setInterval(() => {
        if (prev_time != video.currentTime)
            run()
        prev_time = video.currentTime
    }, 1000 / 30)


    async function run() {
        // Load the MobilenetV2 tflite model from tfhub.
        const tfliteModel = await tflite.loadTFLiteModel('model_docks_v2_back.tflite');

        const outputTensor = tf.tidy(() => {
            // Get pixels data from an image.
            const img = tf.browser.fromPixels(video);
            // Normalize (might also do resize here if necessary).
            const resized = tf.image.resizeBilinear(img, [192, 192]);

            const input = tf.cast(tf.expandDims(resized), 'int32');

            // console.log('input', input.dataSync())
            // const input = tf.sub(tf.div(tf.expandDims(img), 127.5), 1);
            // Run the inference.
            let outputTensor = tfliteModel.predict(input);
            // De-normalize the result.     

            return outputTensor
        });



        const bboxes = outputTensor['TFLite_Detection_PostProcess'].dataSync()
        const confidences = outputTensor['TFLite_Detection_PostProcess:2'].dataSync()

        render_bboxes(bboxes, confidences)


        // classes   
        //   console.log(outputTensor['TFLite_Detection_PostProcess:1'].dataSync())
        //   console.log(outputTensor['TFLite_Detection_PostProcess:3'].dataSync())

    }


    function render_bboxes(bboxes, confidences) {


        for (let i = 0; i < confidences.length; i++) {
            const conf = confidences[i]
            const bbox = bboxes.slice(i * 4, (i * 4) + 4)
            if (conf >= getConfidenceValue())
                draw_bbox(bbox, conf)
        }

    }

    // run()

    const canvas = document.getElementById('canvas')
    // const [canvas_height, canvas_width] = [300, 300]
    const draw = SVG().addTo('#canvas')

    function draw_bbox(bbox, opacity) {

        const canvas_height = canvas.clientHeight
        const canvas_width = canvas.clientWidth

        console.log(canvas_height, canvas_width)


        const [y1, x1, y2, x2] = bbox;

        const bbox_x = x1 * canvas_width
        const bbox_y = y1 * canvas_height
        const bbox_width = (x2 - x1) * canvas_width
        const bbox_height = (y2 - y1) * canvas_height

        var rect = draw.rect(bbox_width, bbox_height).move(bbox_x, bbox_y).fill('none').stroke({ color: '#f06', opacity: opacity, width: 5 })
        var text = draw.text(String(opacity.toFixed(2))).font({ size: 16 }).move(bbox_x, bbox_y).fill('#ffffff')
    }




</script>